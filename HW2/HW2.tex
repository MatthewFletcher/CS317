\documentclass{article}

%Header Dimensions
%https://tex.stackexchange.com/questions/40183/problem-with-the-header-footer-width#40184
\usepackage[margin=0.5in,bottom=0.5in,top=0.5in]{geometry}

%Package required for empty set
\usepackage{amssymb}

%Package required for Comb/Perm symbol and matrices
\usepackage{amsmath}

%Package for graphics
\usepackage{graphicx}

%Package for placing graphics
\usepackage{float}

%Places box around graphics
% Uncomment to box 
% \floatstyle{boxed} 
% \restylefloat{figure}


%For inserting code
\usepackage{listings}
%https://www.sharelatex.com/learn/Code_listing

\begin{document}

	
%%%%%%%%%%%%%%%%%
%CUSTOM COMMANDS%
%%%%%%%%%%%%%%%%%

	%This line surpresses the page number
%https://tex.stackexchange.com/questions/7355/how-to-suppress-page-number
\thispagestyle{empty}

%Make empty set pretty
% https://tex.stackexchange.com/questions/22798/nice-looking-empty-setup
\let\oldemptyset\emptyset
\let\emptyset\varnothing


%Combinatorial notation
%From https://tex.stackexchange.com/questions/107125/is-there-a-command-to-write-the-form-of-a-combination-or-permutation
\newcommand*{\Perm}[2]{{}^{#1}\!P_{#2}}
\newcommand*{\Comb}[2]{{}_{#1}C_{#2}}


	
\textbf{	Matt Fletcher CS317-02 Homework 1}
\smallskip


1.  


\begin{figure}[H]
\includegraphics[scale=0.5]{./P1/sorted}
\centering
\end{figure}

\noindent\rule{8cm}{0.4pt}



2. 

Three steps:

a) Move R to left, and L to R until $R<P$ and $L>P$. 

b) If during (a) R and L did not cross, swap R and L, and continue (a). 

c). If during (a) R and L did cross, swap R and P, freeze P in its new place, split the list in 2 around P, and recursively continue (a) on each new list. 

An asterisk next to an element indicates that it is frozen. 

\begin{lstlisting}
P 	L 							R
43	21	90	8	44	35	6	2	13

P 		L 						R
43	21	90	8	44	35	6	2	13

P 		R 						L
43	21	13	8	44	35	6	2	90

P 		L 						R
43	21	13	8	44	35	6	2	90

P 		 		L			R	
43	21	13	8	44	35	6	2	90

P 		 		L			R	
43	21	13	8	2	35	6	44	90

P 		 				R	L	
43	21	13	8	2	35	6	44	90

R 		 				P	L	
6	21	13	8	2	35	43	44	90

P	L	 			R		PL	R
6	21	13	8	2	35	43*	44	90

P	L	 		R			PR	L
6	21	13	8	2	35	43*	44	90

P	R	L 						
6	2	13	8	21	35	43*	44*	90

		P 	L		R			
2	6*	13	8	21	35	43*	44*	90

		P 	R	L				
2	6*	13	8	21	35	43*	44*	90

		 		PL	R			
2	6*	8	13*	21	35	43*	44*	90

		 		PR	L			
2	6*	8	13*	21	35	43*	44*	90

		 						
2	6*	8	13*	21*	35	43*	44*	90

\end{lstlisting}

All elements are either frozen or single element lists, therefore, the list is sorted. 

\noindent\rule{8cm}{0.4pt}

3. 

Five applications of graph theory: social media connections, navigation, cellular connections to towers, circuit design, register allocation

\noindent\rule{8cm}{0.4pt}


4. 
A directed graph has edges which indicate the direction they travel. The direction of travel cannot oppose the node. On the other hand, an undirected graph allows travel both ways along any edge. 

\noindent\rule{8cm}{0.4pt}

5. 

a) Edges: ac, cf, ab, be, bd
	
	Nodes:a,b,c,d,e,f

b) Edges: fc, ca, ba, be, bd
	
	Nodes:  a,c,f,b,e,d


\noindent\rule{8cm}{0.4pt}

6. 

a) Adjacency List

\begin{lstlisting}
[ a ]-->[ b ]-->[ c ]-->[ d ]-->[ e ]-->[ f ]-->[ g ]
 |       |       |       |       |       |       | 
 v       v       v       v       v       v       v
[->b]   [->d]   [->f]   [->b]   [->b]   [->c]   [->e]
 |       |       |       |       |       |       | 
 v       v       v       v       v       v       v
[->c]   [->e]   [->a]   [->0]   [->g]   [->g]   [->f]
 |       |       |               |       |       | 
 v       v       v               v       v       v
[->0]   [->a]   [->0]           [->0]   [->0]   [->0]
         |
         v
        [->0] 
\end{lstlisting}


a) Adjacency Matrix

\begin{table}[H]
\begin{tabular}{l|l|l|l|l|l|l|l|}
\cline{2-8}
 & A & B & C & D & E & F & G \\ \hline
\multicolumn{1}{|l|}{A} & 0 & 1 & 1 & 0 & 0 & 0 & 0 \\ \hline
\multicolumn{1}{|l|}{B} & 1 & 0 & 0 & 1 & 1 & 0 & 0 \\ \hline
\multicolumn{1}{|l|}{C} & 1 & 0 & 0 & 0 & 0 & 1 & 0 \\ \hline
\multicolumn{1}{|l|}{D} & 0 & 1 & 0 & 0 & 0 & 0 & 0 \\ \hline
\multicolumn{1}{|l|}{E} & 0 & 1 & 0 & 0 & 0 & 0 & 1 \\ \hline
\multicolumn{1}{|l|}{F} & 0 & 0 & 1 & 0 & 0 & 0 & 1 \\ \hline
\multicolumn{1}{|l|}{G} & 0 & 0 & 0 & 0 & 1 & 1 & 0 \\ \hline
\end{tabular}
\end{table}


b) Adjacency List

\begin{lstlisting}
[ a ]-->[ b ]-->[ c ]-->[ d ]-->[ e ]-->[ f ]-->[ g ]
 |       |       |       |       |       |       | 
 v       v       v       v       v       v       v
[->b]   [->d]   [->a]   [->0]   [->0]   [->c]   [->0]
 |       |       |                       |     
 v       v       v                       v    
[->g]   [->e]   [->0]                   [->g]
 |       |                               |  
 v       v                               v   
[->0]   [->0]                           [->0]

\end{lstlisting}

b) Adjacency Matrix

\begin{table}[H]
\begin{tabular}{l|l|l|l|l|l|l|l|}
\cline{2-8}
 & A & B & C & D & E & F & G \\ \hline
\multicolumn{1}{|l|}{A} & 0 & 1 & 0 & 0 & 0 & 0 & 1 \\ \hline
\multicolumn{1}{|l|}{B} & 0 & 0 & 0 & 1 & 1 & 0 & 0 \\ \hline
\multicolumn{1}{|l|}{C} & 1 & 0 & 0 & 0 & 0 & 0 & 0 \\ \hline
\multicolumn{1}{|l|}{D} & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\ \hline
\multicolumn{1}{|l|}{E} & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\ \hline
\multicolumn{1}{|l|}{F} & 0 & 0 & 1 & 0 & 0 & 0 & 1 \\ \hline
\multicolumn{1}{|l|}{G} & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\ \hline
\end{tabular}
\end{table}

\noindent\rule{8cm}{0.4pt}


7.  Traversal order:

A 1/16

B 2/9

C 10/15

D 3/4

E 5/8

F 11/14

G 12/13

Stack order:

Top $\rightarrow$$\rightarrow$$\rightarrow$ $\rightarrow$Bottom

$\boxed{G F C H E D B A}$

\noindent\rule{8cm}{0.4pt}


8.  Traversal order:

A 1

B 2

C 2

D 3

E 3 

F 4

G 5

Queue:

Front $\rightarrow$$\rightarrow$$\rightarrow$ $\rightarrow$Back

$\boxed{A B C D E F G}$

\noindent\rule{8cm}{0.4pt}


9.  

Efficiency of Matrix: $\Theta(\|V^2\|)$

Efficiency of List: $\Theta(\|V\|+  \|E\|)$

\noindent\rule{8cm}{0.4pt}


10. The greedy technique builds a solution piece by piece by picking the most obvious benefit first, without ever reconsidering a decision. It generates a globally optimal solution from a locally optimized choice. 

TODO Greedy algorithm and the greedy choice property. 


\noindent\rule{8cm}{0.4pt}

11. A spanning tree is a set of edges that connects every node in the graph without forming loops or cycles. 


\includegraphics[scale=0.5]{./P11/1}
\includegraphics[scale=0.5]{./P11/2}
\includegraphics[scale=0.5]{./P11/3}
\includegraphics[scale=0.5]{./P11/4}
\includegraphics[scale=0.5]{./P11/5}
\includegraphics[scale=0.5]{./P11/6}
\includegraphics[scale=0.5]{./P11/7}


TODO FIND ALL SPANNING TREES. 

\noindent\rule{8cm}{0.4pt}

12. A minimum spanning tree (MST) is the smallest tree that connects every node in the graph. If the graph is weighted, the smallest tree has the smallest sum of weights. If the graph is unweighted, the MST has the smallest number of edges. 

An example of a minimum spanning tree is determining the minimum amount of wire needed to connect multiple nodes. 

\noindent\rule{8cm}{0.4pt}

13. 

Kruskal's Algorithm: 

$\rightarrow$1. Create a table with each edge sorted in ascending order. 
\begin{table}[H]
\begin{tabular}{|l|l|l|l|l|l|l|l|l|l|l|}
\hline
Edge & CD & DE & AD & AE & BC & AB & BE & BD & AC & BC \\ \hline
Weight & 1 & 2 & 3 & 4 & 5 & 6 & 6 & 8 & 9 & 11 \\ \hline
\end{tabular}
\end{table}


$\rightarrow$2. Starting from either node on the smallest line, attach the next smallest line that does not create a loop. 

Start by attaching line $CD$, weight 1. 

\includegraphics[scale=0.5]{./P13/kruskals/1}

Then, find the smallest weighted edge from any end node that does not create a cycle. This is edge DE. 

\includegraphics[scale=0.5]{./P13/kruskals/2}

Same as before, add edge AD. 

\includegraphics[scale=0.5]{./P13/kruskals/3}

Although AE is the next smallest edge, adding it would create a cycle. So we add BC instead. 

\includegraphics[scale=0.5]{./P13/kruskals/4}

Add the next edge. 

\includegraphics[scale=0.5]{./P13/kruskals/5}

At this point, all the nodes are connected and adding any more lines would result in a cycle being created. Hence, we are done. 



Prims algorithm starts from some vertex (Vertex A in this example) and finds the smallest addition that can be added to the current tree in order to not create a cycle. 

A dashed line indicated that edge has been selected. 

\includegraphics[scale=0.5]{./P13/prims/0}

Start at vertex A. There are 4 edges that can be selected: AE, AD, AC, and AB. AE has the lowest weight, so we select that edge. 

\includegraphics[scale=0.5]{./P13/prims/1}

Now, we check all of the edges coming out of both vertex A and E. The lowest weight gets selected, and we choose edge ED. 

\includegraphics[scale=0.5]{./P13/prims/2}

At this point, we check vertices A, E, and D. Although DA has the lowest weight, it would cause a cycle. So, we skip it and check the other edges. 

\includegraphics[scale=0.5]{./P13/prims/3}

Continuing...

\includegraphics[scale=0.5]{./P13/prims/4}

Almost there...


\includegraphics[scale=0.5]{./P13/prims/5}

And done!




We are done because all vertices have been reached, and no loops or cycles have been created. The total weight is $3+2+1+5+7=\boxed{18}$.






\noindent\rule{8cm}{0.4pt}

14. 

Start at vertex A. Find the shortest path to all other vertices, and indicate in table. Use $\infty$ if there is no path. 


\begin{table}[H]
\begin{tabular}{|l|l|l|l|l|l|l|l|}
\hline
V & \textbf{A} & B & C & D & E & F & G \\ \hline
A & $0_A$ & $7_A$ & $3_A$ & $4_DA$ & $\infty$ & $\infty$ & $\infty$ \\ \hline
\end{tabular}
\end{table}

C is the next unvisited vertex to visit having the smallest tentative distance. Therefore, we visit C and check if there exists a shorter path between A and immediate neighbors of C through C. 



\begin{table}[H]
\begin{tabular}{|l|l|l|l|l|l|l|l|}
\hline
V & \textbf{A} & B & \textbf{C} & D & E & F & G \\ \hline
A & $0_A$ & $7_A$ & $3_A$ & $4_D$ & $\infty$ & $\infty_A$ & $\infty_A$ \\ \hline
C & $0_A$ & $7_A$ & $3_A$ & $4_D$ & $12_C$ & $\infty_A$ & $\infty_A$ \\ \hline
\end{tabular}
\end{table}

Now, check B and see if any paths can be optimized or created. A route to F is possible through B, so we change the value from $\infty$ to $10_B$. 

\begin{table}[H]
\begin{tabular}{|l|l|l|l|l|l|l|l|}
\hline
V & \textbf{A} & \textbf{B} & \textbf{C} & D & E & F & G \\ \hline
A & $0_A$ & $7_A$ & $3_A$ & $4_D$ & $\infty$ & $\infty_A$ & $\infty_A$ \\ \hline
C & $0_A$ & $7_A$ & $3_A$ & $4_D$ & $12_C$ & $\infty$ & $\infty_A$ \\ \hline
B & $0_A$ & $7_A$ & $3_A$ & $4_D$ & $12_C$ & $10_B$ & $\infty_A$ \\ \hline
\end{tabular}
\end{table}

D is the next unvisited node. A route through from A to E through D is now shorter than the current route of A to E through D, therefore, we replace the value. 

\begin{table}[H]
\begin{tabular}{|l|l|l|l|l|l|l|l|}
\hline
V & \textbf{A} & \textbf{B} & \textbf{C} & \textbf{D} & E & F & G \\ \hline
A & $0_A$ & $7_A$ & $3_A$ & $4_D$ & $\infty$ & $\infty_A$ & $\infty_A$ \\ \hline
C & $0_A$ & $7_A$ & $3_A$ & $4_D$ & $12_C$ & $\infty$ & $\infty_A$ \\ \hline
B & $0_A$ & $7_A$ & $3_A$ & $4_D$ & $12_C$ & $10_B$ & $\infty_A$ \\ \hline
D & $0_A$ & $7_A$ & $3_A$ & $4_D$ & $6_D$ & $10_B$ & $14_D$ \\ \hline
\end{tabular}
\end{table}

Next, we visit E. No routes are optimized or created during this visit. 

\begin{table}[H]
\begin{tabular}{|l|l|l|l|l|l|l|l|}
\hline
V & \textbf{A} & \textbf{B} & \textbf{C} & \textbf{D} & \textbf{E} & F & G \\ \hline
A & $0_A$ & $7_A$ & $3_A$ & $4_D$ & $\infty$ & $\infty_A$ & $\infty_A$ \\ \hline
C & $0_A$ & $7_A$ & $3_A$ & $4_D$ & $12_C$ & $\infty$ & $\infty_A$ \\ \hline
B & $0_A$ & $7_A$ & $3_A$ & $4_D$ & $12_C$ & $10_B$ & $\infty_A$ \\ \hline
D & $0_A$ & $7_A$ & $3_A$ & $4_D$ & $6_D$ & $10_B$ & $14_D$ \\ \hline
E & $0_A$ & $7_A$ & $3_A$ & $4_D$ & $6_D$ & $10_B$ & $14_D$ \\ \hline
\end{tabular}
\end{table}

Visit F, no routes optimized. Visit G, no routes optimized. Therefore, the table is finished as follows:

\begin{table}[H]
\begin{tabular}{|l|l|l|l|l|l|l|l|}
\hline
V & \textbf{A} & \textbf{B} & \textbf{C} & \textbf{D} & \textbf{E} & \textbf{F} & \textbf{G} \\ \hline
A & $0_A$ & $7_A$ & $3_A$ & $4_D$ & $\infty$ & $\infty_A$ & $\infty_A$ \\ \hline
C & $0_A$ & $7_A$ & $3_A$ & $4_D$ & $12_C$ & $\infty$ & $\infty_A$ \\ \hline
B & $0_A$ & $7_A$ & $3_A$ & $4_D$ & $12_C$ & $10_B$ & $\infty_A$ \\ \hline
D & $0_A$ & $7_A$ & $3_A$ & $4_D$ & $6_D$ & $10_B$ & $14_D$ \\ \hline
E & $0_A$ & $7_A$ & $3_A$ & $4_D$ & $6_D$ & $10_B$ & $14_D$ \\ \hline
F & $0_A$ & $7_A$ & $3_A$ & $4_D$ & $6_D$ & $10_B$ & $14_D$ \\ \hline
G & $0_A$ & $7_A$ & $3_A$ & $4_D$ & $6_D$ & $10_B$ & $14_D$ \\ \hline
\end{tabular}
\end{table}


\includegraphics[scale=0.5]{./P14/final}






\noindent\rule{8cm}{0.4pt}


15.  

Create a table of the numbers and their count:

\begin{table}[H]
\begin{tabular}{|l|l|l|l|}
\hline
T & N & S & E \\ \hline
1 & 2 & 2 & 4 \\ \hline
\end{tabular}
\end{table}

Insert these into a priority queue: 

\begin{figure}[H]
\includegraphics[scale=0.5]{./P15/0}
\centering
\end{figure}

Dequeue the first 2 elements T and N, combine into binary tree:

\begin{figure}[H]
\includegraphics[scale=0.5]{./P15/TN}
\centering
\end{figure}

Queue the newly created element into the queue in its proper position. . 

\begin{figure}[H]
\includegraphics[scale=0.5]{./P15/TN_Queue}
\centering
\end{figure}


Dequeue the next 2 elements, place into binary tree, and queue the newly created element. 


\begin{figure}[H]
\includegraphics[scale=0.5]{./P15/STN}
\centering
\end{figure}

\begin{figure}[H]
\includegraphics[scale=0.5]{./P15/STN_Queue}
\centering
\end{figure}


Now, dequeue the 2 elements left in the queue, and insert these into a binary tree. 

\begin{figure}[H]
\includegraphics[scale=0.5]{./P15/ESTN}
\centering
\end{figure}

Now, we assign a value to each node. To the left is 0, to the right is 1. 


\begin{figure}[H]
\includegraphics[scale=0.5]{./P15/Scored}
\centering
\end{figure}

According to this, E gets replaced with a 0, S with a 10, T with a 110, and N with a 111. 

Therefore, TENNESSEE gets converted to 110 0 111 111 0 10 10 0 0. 

This is 17 bits, compared to the original 9 8 bit ASCII characters equaling 72 bits. 



\noindent\rule{8cm}{0.4pt}

16. 

Begin by creating a heap. 

Array: 9,4,1,6,3,8,2,10

Take the first element, put it as the root. 
\begin{figure}[H]
\includegraphics[scale=0.5]{./P16/0}
\centering
\end{figure}

Take the next element, and attach it to the bottom left. No reheaping necessary, because $4<9$. 

\begin{figure}[H]
\includegraphics[scale=0.5]{./P16/1}
\centering
\end{figure}

Add the next element to the bottom right. No reheaping necessary. 

\begin{figure}[H]
\includegraphics[scale=0.5]{./P16/2}
\centering
\end{figure}


Add the next element to the bottom left of $4$. Because $6>4$, a reheaping is necessary. 

\begin{figure}[H]
\includegraphics[scale=0.5]{./P16/3}
\centering
\end{figure}


Reheaped. 

\begin{figure}[H]
\includegraphics[scale=0.5]{./P16/4}
\centering
\end{figure}


Continue this algorithm until all elements have been added to the list (some steps omitted for clarity.)

\begin{figure}[H]
\includegraphics[scale=0.5]{./P16/0full}
\centering
\end{figure}

Now, swap the root element (the max, 10) with the bottom right element (2), and delete the max element. This max element is the largest in the list. 

\begin{figure}[H]
\includegraphics[scale=0.5]{./P16/r10}
\centering
\end{figure}


Now, reheap. From the bottom up, check if any elements are greater than their parents. 


\begin{figure}[H]
\includegraphics[scale=0.5]{./P16/m9}
\centering
\end{figure}

Swap max key with bottom right key, delete max key, reheap. Append this deleted key to the deleted list. 

\begin{figure}[H]
\includegraphics[scale=0.5]{./P16/r9}
\centering
\end{figure}

\begin{figure}[H]
\includegraphics[scale=0.5]{./P16/m8}
\centering
\end{figure}

Same as before. 

\begin{figure}[H]
\includegraphics[scale=0.5]{./P16/r8}
\centering
\end{figure}

\begin{figure}[H]
\includegraphics[scale=0.5]{./P16/m6}
\centering
\end{figure}

Same again. 

\begin{figure}[H]
\includegraphics[scale=0.5]{./P16/r6}
\centering
\end{figure}


\begin{figure}[H]
\includegraphics[scale=0.5]{./P16/m4}
\centering
\end{figure}

I'm getting tired. 

\begin{figure}[H]
\includegraphics[scale=0.5]{./P16/r4}
\centering
\end{figure}

\begin{figure}[H]
\includegraphics[scale=0.5]{./P16/m3}
\centering
\end{figure}

So close to done. 

\begin{figure}[H]
\includegraphics[scale=0.5]{./P16/r3}
\centering
\end{figure}

\begin{figure}[H]
\includegraphics[scale=0.5]{./P16/m2}
\centering
\end{figure}

One more....

\begin{figure}[H]
\includegraphics[scale=0.5]{./P16/r2}
\centering
\end{figure}


\begin{figure}[H]
\includegraphics[scale=0.5]{./P16/m1}
\centering
\end{figure}

And we're done. 

Sorted list: 
1,2,3,4,6,8,9,10




\noindent\rule{8cm}{0.4pt}

17. 


\noindent\rule{8cm}{0.4pt}


18. 


\noindent\rule{8cm}{0.4pt}

\end{document}
